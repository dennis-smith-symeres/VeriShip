@using VeriShip.Domain.Entities.QCSpecifications


<TelerikDialog Title="@Title"
               @ref="DialogRef"
               Visible="@Visible"
               VisibleChanged="@VisibleChanged"
               Width="600px"
               Height="600px"
               Class="fixed-dialog"
               FocusedElementSelector="#filter-value"

>
    <DialogContent>
        <div class="dialog-content" >
        <div style="position: sticky; top: 0; z-index: 1; background: #fff;">

            <TelerikTextBox Value="@FilteredValue"

                            DebounceDelay="200"
                            ValueChanged="@((string input) => OnFilterChanged(input))"
                            Id="filter-value"/>
        </div>

         
                <TelerikTreeView Data="@FilteredNodes"
                                    CheckParents="true"
                                 Size="@ThemeConstants.TreeView.Size.Small"
                                 CheckBoxMode="TreeViewCheckBoxMode.Multiple"
                                 CheckedItems="@SelectedTreeItems"
                                 ExpandedItems="@ExpandedItems"
                                 
                                 CheckedItemsChanged="@OnCheckedItemsChanged"
                                 CheckOnClick="true">
                    <TreeViewBindings>
                        <TreeViewBinding ParentIdField="Parent"></TreeViewBinding>
                    </TreeViewBindings>
                </TelerikTreeView>
         


        </div>
    </DialogContent>
    <DialogButtons>
        <TelerikButton OnClick="@(async () => { await VisibleChanged.InvokeAsync(); })">Cancel</TelerikButton>
        <TelerikButton ThemeColor="@(ThemeConstants.Button.ThemeColor.Primary)" OnClick="@OnConfirm">Confirm
        </TelerikButton>
    </DialogButtons>
</TelerikDialog>


@code {

    [Parameter] public IEnumerable<QcSpecification> AllQcSpecifications { get; set; } = [];
    [Parameter] public bool Visible { get; set; }
    [Parameter] public EventCallback<bool> VisibleChanged { get; set; }
    [Parameter] public Table CoATable { get; set; }
    [Parameter] public IEnumerable<int> SelectedIds { get; set; } = [];
    [Parameter] public EventCallback<IEnumerable<int>> OnSelectedChanged { get; set; }

    public string Title { get; set; } = "";

    private HashSet<int> MasterSelectedIds { get; set; } = [];

    public IEnumerable<TreeItem> FilteredNodes { get; set; } = [];

    public IEnumerable<TreeItem> SelectedTreeItems { get; set; }

    public IEnumerable<object> ExpandedItems { get; set; } = [];

    public string FilteredValue { get; set; } = string.Empty;


    TelerikDialog DialogRef;

    protected override void OnParametersSet()
    {
        Title = CoATable == Table.GeneralInformation
            ? $"Add / remove General information"
            : "Add / remove Test and results";


        MasterSelectedIds = SelectedIds?.ToHashSet() ?? [];

        ApplyFilter(FilteredValue);
    }

    private void OnFilterChanged(string input)
    {
        FilteredValue = input;
        ApplyFilter(input);
    }


    private void ApplyFilter(string input)
    {
        var filteredQcSpecifications = string.IsNullOrWhiteSpace(input)
            ? AllQcSpecifications.Where(x => x.Table == CoATable)
            : AllQcSpecifications.Where(x => x.Table == CoATable)
                .Where(x =>
                    x.Category.Contains(input, StringComparison.OrdinalIgnoreCase)
                    || x.Acceptance.Contains(input, StringComparison.OrdinalIgnoreCase)
                    || (!string.IsNullOrEmpty(x.Technique) && x.Technique.Contains(input, StringComparison.OrdinalIgnoreCase)));

        FilteredNodes = ToTests(filteredQcSpecifications, CoATable);

        SelectedTreeItems = IterateParents(FilteredNodes.Where(x => MasterSelectedIds.Contains(x.Id)));

        ExpandedItems = string.IsNullOrEmpty(input)
            ? new List<TreeItem>()
            : FilteredNodes.Where(n => n.HasChildren).Cast<object>().ToList();

        StateHasChanged();
        DialogRef?.Refresh();
    }

    private List<TreeItem> IterateParents(IEnumerable<TreeItem> treeItems)
    {
        var result = new List<TreeItem>(treeItems);
        var parents = new HashSet<int>();

        foreach (var item in treeItems.Where(x => x.Parent.HasValue))
        {
            AddParentsRecursively(item.Parent.Value, parents);
        }

        result.AddRange(FilteredNodes.Where(x => parents.Contains(x.Id)));
        return result;
    }

    private void AddParentsRecursively(int itemId, HashSet<int> parents)
    {
        if (parents.Contains(itemId))
            return;

        parents.Add(itemId);
        var parentItem = FilteredNodes.FirstOrDefault(x => x.Id == itemId);
        if (parentItem?.Parent.HasValue == true)
        {
            AddParentsRecursively(parentItem.Parent.Value, parents);
        }
    }

    private void OnCheckedItemsChanged(IEnumerable<object> obj)
    {
        var newIds = obj.Cast<TreeItem>().Select(n => n.Id).ToHashSet();
        var oldIds = SelectedTreeItems.Select(n => n.Id).ToHashSet();

        var added = newIds.Except(oldIds).ToList();
        var removed = oldIds.Except(newIds).ToList();
        foreach (var id in added)
        {
            var node = FindNode(id);
            if (node?.HasChildren != true)
            {
                MasterSelectedIds.Add(id);
            }
        }

        foreach (var id in removed)
        {
            var node = FindNode(id);
            if (node?.HasChildren != true)
            {
                MasterSelectedIds.Remove(id);
            }
        }
            
    }

    private TreeItem? FindNode(int id) => FilteredNodes.FirstOrDefault(n => n.Id == id);

    private List<TreeItem> ToTests(IEnumerable<QcSpecification> specifications, Table table)
    {
        var cats = specifications.GroupBy(x => x.Category);
        var i = 1000;
        var data = new List<TreeItem>();
        foreach (var cat in cats)
        {
            i++;
            var catItem = new TreeItem(i, null, cat.Key, true);
            data.Add(catItem);

            if (table == Table.GeneralInformation)
            {
                var acceptances = cat.Select(t => t).ToList();
                if (acceptances.Any())
                {
                    foreach (var acc in acceptances)
                    {
                        var accItem = new TreeItem(acc.Id, catItem.Id, acc.Acceptance, false);
                        data.Add(accItem);
                    }
                }
                else
                {
                    catItem.HasChildren = false;
                }
            }

            if (table == Table.Tests)
            {
                foreach (var tec in cat.GroupBy(c => c.Technique))
                {
                    if (string.IsNullOrEmpty(tec.Key))
                    {
                        continue;
                    }

                    i++;
                    var tecItem = new TreeItem(i, catItem.Id, tec.Key, true);
                    data.Add(tecItem);
                    foreach (var acc in tec.Select(t => t))
                    {
                        var accItem = new TreeItem(acc.Id, tecItem.Id, acc.Acceptance, false);
                        data.Add(accItem);
                    }
                }
            }
        }

        return data.ToList();
    }

    // Enumerate a node and all descendants from the full, unfiltered tree


    public class TreeItem
    {
        public int Id { get; set; }
        public int? Parent { get; set; }
        public string Text { get; set; }

        public bool HasChildren { get; set; }

        public TreeItem(int id, int? parent, string text, bool hasChildren)
        {
            Id = id;
            Parent = parent;
            Text = text;

            HasChildren = hasChildren;
        }
    }

    private async Task OnConfirm()
    {

        await OnSelectedChanged.InvokeAsync(MasterSelectedIds);
        await VisibleChanged.InvokeAsync();
        
    }


}