@using VeriShip.Domain.Entities.QCSpecifications


<TelerikDialog Title="@Title"
               @ref="DialogRef"
               Visible="@Visible" VisibleChanged="@VisibleChanged" Width="600px"  Height="600px"
               Class="fixed-dialog"
>
    <DialogContent >
        <div class="dialog-scroll">
       
            <TelerikTextBox Value="@FilteredValue"
                            DebounceDelay="200"
                            ValueChanged="@((string input) => OnFilterChanged(input))" Id="filter-value"/>

            <TelerikTreeView Data="@FilteredNodes"

                             Size="@ThemeConstants.TreeView.Size.Small"
                             CheckBoxMode="TreeViewCheckBoxMode.Multiple"
                             @bind-CheckedItems="VisibleCheckedItems"

                             ExpandedItems="@ExpandedItems"
                             CheckParents="true"
                             CheckOnClick="true">
                <TreeViewBindings>
                    <TreeViewBinding ParentIdField="Parent"></TreeViewBinding>
                </TreeViewBindings>
            </TelerikTreeView>

        </div>
    </DialogContent>
    <DialogButtons>
        <TelerikButton OnClick="@(() => { Visible = false; })">Cancel</TelerikButton>
        <TelerikButton ThemeColor="@(ThemeConstants.Button.ThemeColor.Primary)" OnClick="@OnConfirm">Confirm</TelerikButton>
    </DialogButtons>
</TelerikDialog>


@code {

    [Parameter] public bool Visible { get; set; }
    [Parameter] public EventCallback<bool> VisibleChanged { get; set; }
    [Parameter] public Table CoATable { get; set; }
    [Parameter] public IEnumerable<int> SelectedIds { get; set; } = [];

    [Parameter] public IEnumerable<QcSpecification> AllQcSpecifications { get; set; } = [];
    [Parameter] public IEnumerable<QcSpecification> ShownQcSpecifications { get; set; } = [];
    [Parameter] public EventCallback<IEnumerable<int>> OnSelectedChanged { get; set; }

    public string Title { get; set; } = "";
    // Master selection store (persists across filters)
    private HashSet<int> MasterSelectedIds { get; set; } = new();
    // Backing field for visible checked items binding
    private IEnumerable<object> _visibleCheckedItems = Array.Empty<object>();
    public IEnumerable<object> VisibleCheckedItems
    {
        get
        {
            // reflect master selection into currently visible nodes
            _visibleCheckedItems = FilteredNodes
                .Where(n => MasterSelectedIds.Contains(n.Id))
                .Cast<object>()
                .ToList();
            return _visibleCheckedItems;
        }
        set
        {
            var oldVisible = _visibleCheckedItems.Cast<TreeItem>().Select(n => n.Id).ToHashSet();
            var newVisible = (value ?? Array.Empty<object>()).Cast<TreeItem>().Select(n => n.Id).ToHashSet();

            var added = newVisible.Except(oldVisible).ToList();
            var removed = oldVisible.Except(newVisible).ToList();

            // Update master selection including descendants (even if currently filtered out)
            foreach (var d in added)
            {
                // foreach (var d in EnumerateWithDescendants(id))
                // {
                    if (d < 1000)
                    {
                    MasterSelectedIds.Add(d);
                        
                    }
                    
                // }
            }
            foreach (var id in removed)
            {
                foreach (var d in EnumerateWithDescendants(id))
                {
                    MasterSelectedIds.Remove(d);
                    
                }
            }

            _visibleCheckedItems = value ?? Array.Empty<object>();
            StateHasChanged();

        }
    }
    public IEnumerable<TreeItem> FilteredNodes { get; set; } = [];
    public IEnumerable<object> ExpandedItems { get; set; } = [];
    private List<TreeItem> AllNodes { get; set; } = new();
    private int treeVersion;
    public string FilteredValue { get; set; } = string.Empty;
    TelerikDialog DialogRef;

    protected override void OnParametersSet()
    {
        Title = CoATable == Table.GeneralInformation
            ? $"Add / remove General information"
            : "Add / remove Test and results";

        ShownQcSpecifications = AllQcSpecifications.Where(i => i.Table == CoATable).ToList();

        // Build full (unfiltered) tree once and seed master selections
        AllNodes = ToTests(ShownQcSpecifications, CoATable);
        MasterSelectedIds = SelectedIds?.ToHashSet() ?? [];

        ApplyFilter(FilteredValue);
    }
    private void OnFilterChanged(string input)
    {
        FilteredValue = input;
        ApplyFilter(input);
    }


    private void ApplyFilter(string input)
    {
        var filtered = string.IsNullOrWhiteSpace(input)
            ? ShownQcSpecifications
            : ShownQcSpecifications.Where(x =>
                x.Category.Contains(input, StringComparison.OrdinalIgnoreCase)
                || x.Acceptance.Contains(input, StringComparison.OrdinalIgnoreCase)
                || (!string.IsNullOrEmpty(x.Technique) && x.Technique.Contains(input, StringComparison.OrdinalIgnoreCase)));

        FilteredNodes = ToTests(filtered, CoATable);

        // Expand groups when filtering so matches are visible
        ExpandedItems = string.IsNullOrEmpty(input)
            ? new List<TreeItem>()
            : FilteredNodes.Where(n => n.HasChildren).Cast<object>().ToList();

        // Refresh visible checked items from master selection
        _visibleCheckedItems = FilteredNodes
            .Where(n => MasterSelectedIds.Contains(n.Id))
            .Cast<object>()
            .ToList();

        DialogRef?.Refresh();
        treeVersion++;
    }


    private List<TreeItem> ToTests(IEnumerable<QcSpecification> specifications, Table table)
    {
        var cats = specifications.GroupBy(x => x.Category);
        var i = 1000;
        var data = new List<TreeItem>();
        foreach (var cat in cats)
        {
            i++;
            var catItem = new TreeItem(i, null, cat.Key, true);
            data.Add(catItem);

            if (table == Table.GeneralInformation)
            {
                var acceptances = cat.Select(t => t).ToList();
                if (acceptances.Any())
                {
                    foreach (var acc in acceptances)
                    {
                        var accItem = new TreeItem(acc.Id, catItem.Id, acc.Acceptance, false);
                        data.Add(accItem);
                    }
                }
                else
                {
                    catItem.HasChildren = false;
                }

            }

            if (table == Table.Tests)
            {
                foreach (var tec in cat.GroupBy(c => c.Technique))
                {
                    if (string.IsNullOrEmpty(tec?.Key))
                    {
                        continue;
                    }
                    i++;
                    var tecItem = new TreeItem(i, catItem.Id, tec.Key, true);
                    data.Add(tecItem);
                    foreach (var acc in tec.Select(t => t))
                    {

                        var accItem = new TreeItem(acc.Id, tecItem.Id, acc.Acceptance, false);
                        data.Add(accItem);
                    }
                }
            }



        }

        return data.ToList();
    }

    // Enumerate a node and all descendants from the full, unfiltered tree
    private IEnumerable<int> EnumerateWithDescendants(int id)
    {
        yield return id;
        foreach (var child in AllNodes.Where(n => n.Parent == id))
        {
            foreach (var d in EnumerateWithDescendants(child.Id))
                yield return d;
        }
    }


    public class TreeItem
    {
        public int Id { get; set; }
        public int? Parent { get; set; }
        public string Text { get; set; }

        public bool HasChildren { get; set; }

        public TreeItem(int id, int? parent, string text,  bool hasChildren)
        {
            Id = id;
            Parent = parent;
            Text = text;

            HasChildren = hasChildren;
        }
    }

    private async Task OnConfirm()
    {
        // Emit the full selection (including items currently hidden by filter)
        await OnSelectedChanged.InvokeAsync(MasterSelectedIds);
        Visible = false;
    }

}